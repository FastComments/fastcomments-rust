/*
 * fastcomments
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`block_from_comment_public`]
#[derive(Clone, Debug)]
pub struct BlockFromCommentPublicParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub public_block_from_comment_params: models::PublicBlockFromCommentParams,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`checked_comments_for_blocked`]
#[derive(Clone, Debug)]
pub struct CheckedCommentsForBlockedParams {
    pub tenant_id: String,
    /// A comma separated list of comment ids.
    pub comment_ids: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`create_comment_public`]
#[derive(Clone, Debug)]
pub struct CreateCommentPublicParams {
    pub tenant_id: String,
    pub url_id: String,
    pub broadcast_id: String,
    pub comment_data: models::CommentData,
    pub session_id: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`create_feed_post_public`]
#[derive(Clone, Debug)]
pub struct CreateFeedPostPublicParams {
    pub tenant_id: String,
    pub create_feed_post_params: models::CreateFeedPostParams,
    pub broadcast_id: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`delete_comment_public`]
#[derive(Clone, Debug)]
pub struct DeleteCommentPublicParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub broadcast_id: String,
    pub edit_key: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`delete_comment_vote`]
#[derive(Clone, Debug)]
pub struct DeleteCommentVoteParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub vote_id: String,
    pub url_id: String,
    pub broadcast_id: String,
    pub edit_key: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`delete_feed_post_public`]
#[derive(Clone, Debug)]
pub struct DeleteFeedPostPublicParams {
    pub tenant_id: String,
    pub post_id: String,
    pub broadcast_id: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`flag_comment_public`]
#[derive(Clone, Debug)]
pub struct FlagCommentPublicParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub is_flagged: bool,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`get_comment_text`]
#[derive(Clone, Debug)]
pub struct GetCommentTextParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub edit_key: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`get_comment_vote_user_names`]
#[derive(Clone, Debug)]
pub struct GetCommentVoteUserNamesParams {
    pub tenant_id: String,
    pub comment_id: String,
    /// Pass 1 for getting the names of users that up voted, and -1 for the usernames for users that down voted.
    pub direction: f64,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`get_comments_public`]
#[derive(Clone, Debug)]
pub struct GetCommentsPublicParams {
    pub tenant_id: String,
    pub url_id: String,
    pub page: Option<i32>,
    pub direction: Option<models::SortDirections>,
    pub sso: Option<String>,
    pub skip: Option<i32>,
    pub skip_children: Option<i32>,
    pub limit: Option<i32>,
    pub limit_children: Option<i32>,
    pub count_children: Option<bool>,
    pub last_gen_date: Option<i64>,
    pub fetch_page_for_comment_id: Option<String>,
    pub include_config: Option<bool>,
    pub count_all: Option<bool>,
    pub includei10n: Option<bool>,
    pub locale: Option<String>,
    pub modules: Option<String>,
    pub is_crawler: Option<bool>,
    pub include_notification_count: Option<bool>,
    pub as_tree: Option<bool>,
    pub max_tree_depth: Option<i32>,
    pub use_full_translation_ids: Option<bool>,
    pub parent_id: Option<String>,
    pub search_text: Option<String>,
    pub hash_tags: Option<Vec<String>>,
    pub user_id: Option<String>,
    pub custom_config_str: Option<String>
}

/// struct for passing parameters to the method [`get_event_log`]
#[derive(Clone, Debug)]
pub struct GetEventLogParams {
    pub tenant_id: String,
    pub url_id: String,
    pub user_id_ws: String,
    pub start_time: i64,
    pub end_time: i64
}

/// struct for passing parameters to the method [`get_feed_posts_public`]
#[derive(Clone, Debug)]
pub struct GetFeedPostsPublicParams {
    pub tenant_id: String,
    pub after_id: Option<String>,
    pub limit: Option<i32>,
    pub tags: Option<Vec<String>>,
    pub sso: Option<String>,
    pub is_crawler: Option<bool>,
    pub include_user_info: Option<bool>
}

/// struct for passing parameters to the method [`get_feed_posts_stats`]
#[derive(Clone, Debug)]
pub struct GetFeedPostsStatsParams {
    pub tenant_id: String,
    pub post_ids: Vec<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`get_global_event_log`]
#[derive(Clone, Debug)]
pub struct GetGlobalEventLogParams {
    pub tenant_id: String,
    pub url_id: String,
    pub user_id_ws: String,
    pub start_time: i64,
    pub end_time: i64
}

/// struct for passing parameters to the method [`get_user_notification_count`]
#[derive(Clone, Debug)]
pub struct GetUserNotificationCountParams {
    pub tenant_id: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`get_user_notifications`]
#[derive(Clone, Debug)]
pub struct GetUserNotificationsParams {
    pub tenant_id: String,
    /// Defaults to 20.
    pub page_size: Option<f64>,
    pub after_id: Option<String>,
    pub include_context: Option<bool>,
    pub after_created_at: Option<f64>,
    pub unread_only: Option<bool>,
    pub dm_only: Option<bool>,
    pub no_dm: Option<bool>,
    pub include_translations: Option<bool>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`get_user_presence_statuses`]
#[derive(Clone, Debug)]
pub struct GetUserPresenceStatusesParams {
    pub tenant_id: String,
    pub url_id_ws: String,
    pub user_ids: String
}

/// struct for passing parameters to the method [`get_user_reacts_public`]
#[derive(Clone, Debug)]
pub struct GetUserReactsPublicParams {
    pub tenant_id: String,
    pub post_ids: Option<Vec<String>>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`lock_comment`]
#[derive(Clone, Debug)]
pub struct LockCommentParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub broadcast_id: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`pin_comment`]
#[derive(Clone, Debug)]
pub struct PinCommentParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub broadcast_id: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`react_feed_post_public`]
#[derive(Clone, Debug)]
pub struct ReactFeedPostPublicParams {
    pub tenant_id: String,
    pub post_id: String,
    pub react_body_params: models::ReactBodyParams,
    pub is_undo: Option<bool>,
    pub broadcast_id: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`reset_user_notification_count`]
#[derive(Clone, Debug)]
pub struct ResetUserNotificationCountParams {
    pub tenant_id: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`reset_user_notifications`]
#[derive(Clone, Debug)]
pub struct ResetUserNotificationsParams {
    pub tenant_id: String,
    pub after_id: Option<String>,
    pub after_created_at: Option<f64>,
    pub unread_only: Option<bool>,
    pub dm_only: Option<bool>,
    pub no_dm: Option<bool>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`set_comment_text`]
#[derive(Clone, Debug)]
pub struct SetCommentTextParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub broadcast_id: String,
    pub comment_text_update_request: models::CommentTextUpdateRequest,
    pub edit_key: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`un_block_comment_public`]
#[derive(Clone, Debug)]
pub struct UnBlockCommentPublicParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub public_block_from_comment_params: models::PublicBlockFromCommentParams,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`un_lock_comment`]
#[derive(Clone, Debug)]
pub struct UnLockCommentParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub broadcast_id: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`un_pin_comment`]
#[derive(Clone, Debug)]
pub struct UnPinCommentParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub broadcast_id: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`update_feed_post_public`]
#[derive(Clone, Debug)]
pub struct UpdateFeedPostPublicParams {
    pub tenant_id: String,
    pub post_id: String,
    pub update_feed_post_params: models::UpdateFeedPostParams,
    pub broadcast_id: Option<String>,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`update_user_notification_comment_subscription_status`]
#[derive(Clone, Debug)]
pub struct UpdateUserNotificationCommentSubscriptionStatusParams {
    pub tenant_id: String,
    pub notification_id: String,
    pub opted_in_or_out: String,
    pub comment_id: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`update_user_notification_page_subscription_status`]
#[derive(Clone, Debug)]
pub struct UpdateUserNotificationPageSubscriptionStatusParams {
    pub tenant_id: String,
    pub url_id: String,
    pub url: String,
    pub page_title: String,
    pub subscribed_or_unsubscribed: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`update_user_notification_status`]
#[derive(Clone, Debug)]
pub struct UpdateUserNotificationStatusParams {
    pub tenant_id: String,
    pub notification_id: String,
    pub new_status: String,
    pub sso: Option<String>
}

/// struct for passing parameters to the method [`upload_image`]
#[derive(Clone, Debug)]
pub struct UploadImageParams {
    pub tenant_id: String,
    pub file: std::path::PathBuf,
    /// Size preset: \"Default\" (1000x1000px) or \"CrossPlatform\" (creates sizes for popular devices)
    pub size_preset: Option<models::SizePreset>,
    /// Page id that upload is happening from, to configure
    pub url_id: Option<String>
}

/// struct for passing parameters to the method [`vote_comment`]
#[derive(Clone, Debug)]
pub struct VoteCommentParams {
    pub tenant_id: String,
    pub comment_id: String,
    pub url_id: String,
    pub broadcast_id: String,
    pub vote_body_params: models::VoteBodyParams,
    pub session_id: Option<String>,
    pub sso: Option<String>
}


/// struct for typed errors of method [`block_from_comment_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlockFromCommentPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checked_comments_for_blocked`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckedCommentsForBlockedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_comment_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCommentPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_feed_post_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateFeedPostPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_comment_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCommentPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_comment_vote`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCommentVoteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_feed_post_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteFeedPostPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`flag_comment_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FlagCommentPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comment_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comment_vote_user_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentVoteUserNamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comments_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentsPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_event_log`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetEventLogError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_feed_posts_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFeedPostsPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_feed_posts_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetFeedPostsStatsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_global_event_log`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGlobalEventLogError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_notification_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserNotificationCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_presence_statuses`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserPresenceStatusesError {
    Status422(models::ApiError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_reacts_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserReactsPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lock_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LockCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pin_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PinCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`react_feed_post_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ReactFeedPostPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_user_notification_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetUserNotificationCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_user_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetUserNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_comment_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCommentTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`un_block_comment_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnBlockCommentPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`un_lock_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnLockCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`un_pin_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnPinCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_feed_post_public`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateFeedPostPublicError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_notification_comment_subscription_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserNotificationCommentSubscriptionStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_notification_page_subscription_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserNotificationPageSubscriptionStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_notification_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserNotificationStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadImageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vote_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VoteCommentError {
    UnknownValue(serde_json::Value),
}


pub async fn block_from_comment_public(configuration: &configuration::Configuration, params: BlockFromCommentPublicParams) -> Result<models::BlockFromCommentPublic200Response, Error<BlockFromCommentPublicError>> {

    let uri_str = format!("{}/block-from-comment/{commentId}", configuration.base_path, commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.public_block_from_comment_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<BlockFromCommentPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn checked_comments_for_blocked(configuration: &configuration::Configuration, params: CheckedCommentsForBlockedParams) -> Result<models::CheckedCommentsForBlocked200Response, Error<CheckedCommentsForBlockedError>> {

    let uri_str = format!("{}/check-blocked-comments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    req_builder = req_builder.query(&[("commentIds", &params.comment_ids.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckedCommentsForBlockedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_comment_public(configuration: &configuration::Configuration, params: CreateCommentPublicParams) -> Result<models::CreateCommentPublic200Response, Error<CreateCommentPublicError>> {

    let uri_str = format!("{}/comments/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("urlId", &params.url_id.to_string())]);
    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.session_id {
        req_builder = req_builder.query(&[("sessionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.comment_data);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateCommentPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_feed_post_public(configuration: &configuration::Configuration, params: CreateFeedPostPublicParams) -> Result<models::CreateFeedPostPublic200Response, Error<CreateFeedPostPublicError>> {

    let uri_str = format!("{}/feed-posts/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.broadcast_id {
        req_builder = req_builder.query(&[("broadcastId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.create_feed_post_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateFeedPostPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_comment_public(configuration: &configuration::Configuration, params: DeleteCommentPublicParams) -> Result<models::DeleteCommentPublic200Response, Error<DeleteCommentPublicError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.edit_key {
        req_builder = req_builder.query(&[("editKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteCommentPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_comment_vote(configuration: &configuration::Configuration, params: DeleteCommentVoteParams) -> Result<models::DeleteCommentVote200Response, Error<DeleteCommentVoteError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/vote/{voteId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id), voteId=crate::apis::urlencode(params.vote_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("urlId", &params.url_id.to_string())]);
    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.edit_key {
        req_builder = req_builder.query(&[("editKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteCommentVoteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_feed_post_public(configuration: &configuration::Configuration, params: DeleteFeedPostPublicParams) -> Result<models::DeleteFeedPostPublic200Response, Error<DeleteFeedPostPublicError>> {

    let uri_str = format!("{}/feed-posts/{tenantId}/{postId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), postId=crate::apis::urlencode(params.post_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = params.broadcast_id {
        req_builder = req_builder.query(&[("broadcastId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteFeedPostPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn flag_comment_public(configuration: &configuration::Configuration, params: FlagCommentPublicParams) -> Result<models::FlagCommentPublic200Response, Error<FlagCommentPublicError>> {

    let uri_str = format!("{}/flag-comment/{commentId}", configuration.base_path, commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    req_builder = req_builder.query(&[("isFlagged", &params.is_flagged.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<FlagCommentPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_comment_text(configuration: &configuration::Configuration, params: GetCommentTextParams) -> Result<models::GetCommentText200Response, Error<GetCommentTextError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/text", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.edit_key {
        req_builder = req_builder.query(&[("editKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_comment_vote_user_names(configuration: &configuration::Configuration, params: GetCommentVoteUserNamesParams) -> Result<models::GetCommentVoteUserNames200Response, Error<GetCommentVoteUserNamesError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/votes", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("direction", &params.direction.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentVoteUserNamesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  req tenantId urlId
pub async fn get_comments_public(configuration: &configuration::Configuration, params: GetCommentsPublicParams) -> Result<models::GetCommentsPublic200Response, Error<GetCommentsPublicError>> {

    let uri_str = format!("{}/comments/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("urlId", &params.url_id.to_string())]);
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.skip_children {
        req_builder = req_builder.query(&[("skipChildren", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit_children {
        req_builder = req_builder.query(&[("limitChildren", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.count_children {
        req_builder = req_builder.query(&[("countChildren", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.last_gen_date {
        req_builder = req_builder.query(&[("lastGenDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.fetch_page_for_comment_id {
        req_builder = req_builder.query(&[("fetchPageForCommentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_config {
        req_builder = req_builder.query(&[("includeConfig", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.count_all {
        req_builder = req_builder.query(&[("countAll", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.includei10n {
        req_builder = req_builder.query(&[("includei10n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.modules {
        req_builder = req_builder.query(&[("modules", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.is_crawler {
        req_builder = req_builder.query(&[("isCrawler", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_notification_count {
        req_builder = req_builder.query(&[("includeNotificationCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.as_tree {
        req_builder = req_builder.query(&[("asTree", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_tree_depth {
        req_builder = req_builder.query(&[("maxTreeDepth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.use_full_translation_ids {
        req_builder = req_builder.query(&[("useFullTranslationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.search_text {
        req_builder = req_builder.query(&[("searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hash_tags {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("hashTags".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("hashTags", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.custom_config_str {
        req_builder = req_builder.query(&[("customConfigStr", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentsPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  req tenantId urlId userIdWS
pub async fn get_event_log(configuration: &configuration::Configuration, params: GetEventLogParams) -> Result<models::GetEventLog200Response, Error<GetEventLogError>> {

    let uri_str = format!("{}/event-log/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("urlId", &params.url_id.to_string())]);
    req_builder = req_builder.query(&[("userIdWS", &params.user_id_ws.to_string())]);
    req_builder = req_builder.query(&[("startTime", &params.start_time.to_string())]);
    req_builder = req_builder.query(&[("endTime", &params.end_time.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetEventLogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  req tenantId afterId
pub async fn get_feed_posts_public(configuration: &configuration::Configuration, params: GetFeedPostsPublicParams) -> Result<models::GetFeedPostsPublic200Response, Error<GetFeedPostsPublicError>> {

    let uri_str = format!("{}/feed-posts/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.after_id {
        req_builder = req_builder.query(&[("afterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.tags {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("tags".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("tags", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.is_crawler {
        req_builder = req_builder.query(&[("isCrawler", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_user_info {
        req_builder = req_builder.query(&[("includeUserInfo", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFeedPostsPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_feed_posts_stats(configuration: &configuration::Configuration, params: GetFeedPostsStatsParams) -> Result<models::GetFeedPostsStats200Response, Error<GetFeedPostsStatsError>> {

    let uri_str = format!("{}/feed-posts/{tenantId}/stats", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&params.post_ids.into_iter().map(|p| ("postIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("postIds", &params.post_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetFeedPostsStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  req tenantId urlId userIdWS
pub async fn get_global_event_log(configuration: &configuration::Configuration, params: GetGlobalEventLogParams) -> Result<models::GetEventLog200Response, Error<GetGlobalEventLogError>> {

    let uri_str = format!("{}/event-log/global/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("urlId", &params.url_id.to_string())]);
    req_builder = req_builder.query(&[("userIdWS", &params.user_id_ws.to_string())]);
    req_builder = req_builder.query(&[("startTime", &params.start_time.to_string())]);
    req_builder = req_builder.query(&[("endTime", &params.end_time.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGlobalEventLogError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_user_notification_count(configuration: &configuration::Configuration, params: GetUserNotificationCountParams) -> Result<models::GetUserNotificationCount200Response, Error<GetUserNotificationCountError>> {

    let uri_str = format!("{}/user-notifications/get-count", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserNotificationCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_user_notifications(configuration: &configuration::Configuration, params: GetUserNotificationsParams) -> Result<models::GetUserNotifications200Response, Error<GetUserNotificationsError>> {

    let uri_str = format!("{}/user-notifications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.after_id {
        req_builder = req_builder.query(&[("afterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_context {
        req_builder = req_builder.query(&[("includeContext", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.after_created_at {
        req_builder = req_builder.query(&[("afterCreatedAt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unread_only {
        req_builder = req_builder.query(&[("unreadOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.dm_only {
        req_builder = req_builder.query(&[("dmOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.no_dm {
        req_builder = req_builder.query(&[("noDm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_translations {
        req_builder = req_builder.query(&[("includeTranslations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_user_presence_statuses(configuration: &configuration::Configuration, params: GetUserPresenceStatusesParams) -> Result<models::GetUserPresenceStatuses200Response, Error<GetUserPresenceStatusesError>> {

    let uri_str = format!("{}/user-presence-status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    req_builder = req_builder.query(&[("urlIdWS", &params.url_id_ws.to_string())]);
    req_builder = req_builder.query(&[("userIds", &params.user_ids.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserPresenceStatusesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_user_reacts_public(configuration: &configuration::Configuration, params: GetUserReactsPublicParams) -> Result<models::GetUserReactsPublic200Response, Error<GetUserReactsPublicError>> {

    let uri_str = format!("{}/feed-posts/{tenantId}/user-reacts", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.post_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("postIds".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("postIds", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserReactsPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn lock_comment(configuration: &configuration::Configuration, params: LockCommentParams) -> Result<models::LockComment200Response, Error<LockCommentError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/lock", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<LockCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn pin_comment(configuration: &configuration::Configuration, params: PinCommentParams) -> Result<models::PinComment200Response, Error<PinCommentError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/pin", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<PinCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn react_feed_post_public(configuration: &configuration::Configuration, params: ReactFeedPostPublicParams) -> Result<models::ReactFeedPostPublic200Response, Error<ReactFeedPostPublicError>> {

    let uri_str = format!("{}/feed-posts/{tenantId}/react/{postId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), postId=crate::apis::urlencode(params.post_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.is_undo {
        req_builder = req_builder.query(&[("isUndo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.broadcast_id {
        req_builder = req_builder.query(&[("broadcastId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.react_body_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ReactFeedPostPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn reset_user_notification_count(configuration: &configuration::Configuration, params: ResetUserNotificationCountParams) -> Result<models::ResetUserNotifications200Response, Error<ResetUserNotificationCountError>> {

    let uri_str = format!("{}/user-notifications/reset-count", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetUserNotificationCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn reset_user_notifications(configuration: &configuration::Configuration, params: ResetUserNotificationsParams) -> Result<models::ResetUserNotifications200Response, Error<ResetUserNotificationsError>> {

    let uri_str = format!("{}/user-notifications/reset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    if let Some(ref param_value) = params.after_id {
        req_builder = req_builder.query(&[("afterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.after_created_at {
        req_builder = req_builder.query(&[("afterCreatedAt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.unread_only {
        req_builder = req_builder.query(&[("unreadOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.dm_only {
        req_builder = req_builder.query(&[("dmOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.no_dm {
        req_builder = req_builder.query(&[("noDm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetUserNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn set_comment_text(configuration: &configuration::Configuration, params: SetCommentTextParams) -> Result<models::SetCommentText200Response, Error<SetCommentTextError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/update-text", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.edit_key {
        req_builder = req_builder.query(&[("editKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.comment_text_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<SetCommentTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn un_block_comment_public(configuration: &configuration::Configuration, params: UnBlockCommentPublicParams) -> Result<models::UnBlockCommentPublic200Response, Error<UnBlockCommentPublicError>> {

    let uri_str = format!("{}/block-from-comment/{commentId}", configuration.base_path, commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.public_block_from_comment_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UnBlockCommentPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn un_lock_comment(configuration: &configuration::Configuration, params: UnLockCommentParams) -> Result<models::LockComment200Response, Error<UnLockCommentError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/unlock", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UnLockCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn un_pin_comment(configuration: &configuration::Configuration, params: UnPinCommentParams) -> Result<models::PinComment200Response, Error<UnPinCommentError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/unpin", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UnPinCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_feed_post_public(configuration: &configuration::Configuration, params: UpdateFeedPostPublicParams) -> Result<models::CreateFeedPostPublic200Response, Error<UpdateFeedPostPublicError>> {

    let uri_str = format!("{}/feed-posts/{tenantId}/{postId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), postId=crate::apis::urlencode(params.post_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = params.broadcast_id {
        req_builder = req_builder.query(&[("broadcastId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.update_feed_post_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateFeedPostPublicError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable or disable notifications for a specific comment.
pub async fn update_user_notification_comment_subscription_status(configuration: &configuration::Configuration, params: UpdateUserNotificationCommentSubscriptionStatusParams) -> Result<models::UpdateUserNotificationStatus200Response, Error<UpdateUserNotificationCommentSubscriptionStatusError>> {

    let uri_str = format!("{}/user-notifications/{notificationId}/mark-opted/{optedInOrOut}", configuration.base_path, notificationId=crate::apis::urlencode(params.notification_id), optedInOrOut=crate::apis::urlencode(params.opted_in_or_out));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    req_builder = req_builder.query(&[("commentId", &params.comment_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserNotificationCommentSubscriptionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable or disable notifications for a page. When users are subscribed to a page, notifications are created for new root comments, and also
pub async fn update_user_notification_page_subscription_status(configuration: &configuration::Configuration, params: UpdateUserNotificationPageSubscriptionStatusParams) -> Result<models::UpdateUserNotificationStatus200Response, Error<UpdateUserNotificationPageSubscriptionStatusError>> {

    let uri_str = format!("{}/user-notifications/set-subscription-state/{subscribedOrUnsubscribed}", configuration.base_path, subscribedOrUnsubscribed=crate::apis::urlencode(params.subscribed_or_unsubscribed));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    req_builder = req_builder.query(&[("urlId", &params.url_id.to_string())]);
    req_builder = req_builder.query(&[("url", &params.url.to_string())]);
    req_builder = req_builder.query(&[("pageTitle", &params.page_title.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserNotificationPageSubscriptionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_user_notification_status(configuration: &configuration::Configuration, params: UpdateUserNotificationStatusParams) -> Result<models::UpdateUserNotificationStatus200Response, Error<UpdateUserNotificationStatusError>> {

    let uri_str = format!("{}/user-notifications/{notificationId}/mark/{newStatus}", configuration.base_path, notificationId=crate::apis::urlencode(params.notification_id), newStatus=crate::apis::urlencode(params.new_status));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &params.tenant_id.to_string())]);
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserNotificationStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload and resize an image
pub async fn upload_image(configuration: &configuration::Configuration, params: UploadImageParams) -> Result<models::UploadImageResponse, Error<UploadImageError>> {

    let uri_str = format!("{}/upload-image/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = params.size_preset {
        req_builder = req_builder.query(&[("sizePreset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.url_id {
        req_builder = req_builder.query(&[("urlId", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vote_comment(configuration: &configuration::Configuration, params: VoteCommentParams) -> Result<models::VoteComment200Response, Error<VoteCommentError>> {

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/vote", configuration.base_path, tenantId=crate::apis::urlencode(params.tenant_id), commentId=crate::apis::urlencode(params.comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("urlId", &params.url_id.to_string())]);
    req_builder = req_builder.query(&[("broadcastId", &params.broadcast_id.to_string())]);
    if let Some(ref param_value) = params.session_id {
        req_builder = req_builder.query(&[("sessionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&params.vote_body_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<VoteCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

