/*
 * fastcomments
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`block_from_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BlockFromCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`checked_comments_for_blocked`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CheckedCommentsForBlockedError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_comment_vote`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteCommentVoteError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`flag_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FlagCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comment_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comment_vote_user_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentVoteUserNamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_comments`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCommentsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_notification_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserNotificationCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_user_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUserNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`lock_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LockCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pin_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PinCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_user_notification_count`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetUserNotificationCountError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_user_notifications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetUserNotificationsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_comment_text`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetCommentTextError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`un_block_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnBlockCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`un_lock_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnLockCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`un_pin_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnPinCommentError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_notification_comment_subscription_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserNotificationCommentSubscriptionStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_notification_page_subscription_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserNotificationPageSubscriptionStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_user_notification_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateUserNotificationStatusError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`vote_comment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VoteCommentError {
    UnknownValue(serde_json::Value),
}


pub async fn block_from_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, block_from_comment_params: models::BlockFromCommentParams, sso: Option<&str>) -> Result<models::BlockFromComment200Response, Error<BlockFromCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_block_from_comment_params = block_from_comment_params;
    let p_sso = sso;

    let uri_str = format!("{}/block-from-comment/{commentId}", configuration.base_path, commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_block_from_comment_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BlockFromComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BlockFromComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BlockFromCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn checked_comments_for_blocked(configuration: &configuration::Configuration, tenant_id: &str, comment_ids: &str, sso: Option<&str>) -> Result<models::CheckedCommentsForBlocked200Response, Error<CheckedCommentsForBlockedError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_ids = comment_ids;
    let p_sso = sso;

    let uri_str = format!("{}/check-blocked-comments", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    req_builder = req_builder.query(&[("commentIds", &p_comment_ids.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CheckedCommentsForBlocked200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CheckedCommentsForBlocked200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CheckedCommentsForBlockedError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn create_comment(configuration: &configuration::Configuration, tenant_id: &str, url_id: &str, broadcast_id: &str, comment_data: models::CommentData, session_id: Option<&str>, sso: Option<&str>) -> Result<models::CreateComment200Response, Error<CreateCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_url_id = url_id;
    let p_broadcast_id = broadcast_id;
    let p_comment_data = comment_data;
    let p_session_id = session_id;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("urlId", &p_url_id.to_string())]);
    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("sessionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_comment_data);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, broadcast_id: &str, edit_key: Option<&str>) -> Result<models::DeleteComment200Response, Error<DeleteCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_broadcast_id = broadcast_id;
    let p_edit_key = edit_key;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_edit_key {
        req_builder = req_builder.query(&[("editKey", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn delete_comment_vote(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, vote_id: &str, url_id: &str, broadcast_id: &str, edit_key: Option<&str>, sso: Option<&str>) -> Result<models::DeleteCommentVote200Response, Error<DeleteCommentVoteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_vote_id = vote_id;
    let p_url_id = url_id;
    let p_broadcast_id = broadcast_id;
    let p_edit_key = edit_key;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/vote/{voteId}", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id), voteId=crate::apis::urlencode(p_vote_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("urlId", &p_url_id.to_string())]);
    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_edit_key {
        req_builder = req_builder.query(&[("editKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteCommentVote200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteCommentVote200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteCommentVoteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn flag_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, is_flagged: models::BooleanQueryParam, sso: Option<&str>) -> Result<models::FlagComment200Response, Error<FlagCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_is_flagged = is_flagged;
    let p_sso = sso;

    let uri_str = format!("{}/flag-comment/{commentId}", configuration.base_path, commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    req_builder = req_builder.query(&[("isFlagged", &p_is_flagged.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FlagComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FlagComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FlagCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_comment_text(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, edit_key: Option<&str>, sso: Option<&str>) -> Result<models::GetCommentText200Response, Error<GetCommentTextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_edit_key = edit_key;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/text", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_edit_key {
        req_builder = req_builder.query(&[("editKey", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetCommentText200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetCommentText200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_comment_vote_user_names(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, direction: f64, sso: Option<&str>) -> Result<models::GetCommentVoteUserNames200Response, Error<GetCommentVoteUserNamesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_direction = direction;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/votes", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("direction", &p_direction.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetCommentVoteUserNames200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetCommentVoteUserNames200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentVoteUserNamesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  req tenantId urlId
pub async fn get_comments(configuration: &configuration::Configuration, tenant_id: &str, url_id: &str, page: Option<i32>, direction: Option<models::SortDirections>, sso: Option<&str>, skip: Option<i32>, skip_children: Option<i32>, limit: Option<i32>, limit_children: Option<i32>, count_children: Option<models::BooleanQueryParam>, last_gen_date: Option<i64>, fetch_page_for_comment_id: Option<&str>, include_config: Option<models::BooleanQueryParam>, count_all: Option<models::BooleanQueryParam>, includei10n: Option<models::BooleanQueryParam>, locale: Option<&str>, modules: Option<&str>, is_crawler: Option<models::BooleanQueryParam>, include_notification_count: Option<models::BooleanQueryParam>, as_tree: Option<models::BooleanQueryParam>, max_tree_depth: Option<i32>, use_full_translation_ids: Option<models::BooleanQueryParam>, parent_id: Option<&str>, search_text: Option<&str>, hash_tags: Option<Vec<String>>, user_id: Option<&str>, custom_config_str: Option<&str>) -> Result<models::GetComments200Response, Error<GetCommentsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_url_id = url_id;
    let p_page = page;
    let p_direction = direction;
    let p_sso = sso;
    let p_skip = skip;
    let p_skip_children = skip_children;
    let p_limit = limit;
    let p_limit_children = limit_children;
    let p_count_children = count_children;
    let p_last_gen_date = last_gen_date;
    let p_fetch_page_for_comment_id = fetch_page_for_comment_id;
    let p_include_config = include_config;
    let p_count_all = count_all;
    let p_includei10n = includei10n;
    let p_locale = locale;
    let p_modules = modules;
    let p_is_crawler = is_crawler;
    let p_include_notification_count = include_notification_count;
    let p_as_tree = as_tree;
    let p_max_tree_depth = max_tree_depth;
    let p_use_full_translation_ids = use_full_translation_ids;
    let p_parent_id = parent_id;
    let p_search_text = search_text;
    let p_hash_tags = hash_tags;
    let p_user_id = user_id;
    let p_custom_config_str = custom_config_str;

    let uri_str = format!("{}/comments/{tenantId}", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("urlId", &p_url_id.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip {
        req_builder = req_builder.query(&[("skip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_skip_children {
        req_builder = req_builder.query(&[("skipChildren", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit_children {
        req_builder = req_builder.query(&[("limitChildren", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count_children {
        req_builder = req_builder.query(&[("countChildren", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_last_gen_date {
        req_builder = req_builder.query(&[("lastGenDate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_fetch_page_for_comment_id {
        req_builder = req_builder.query(&[("fetchPageForCommentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_config {
        req_builder = req_builder.query(&[("includeConfig", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_count_all {
        req_builder = req_builder.query(&[("countAll", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_includei10n {
        req_builder = req_builder.query(&[("includei10n", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_locale {
        req_builder = req_builder.query(&[("locale", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_modules {
        req_builder = req_builder.query(&[("modules", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_is_crawler {
        req_builder = req_builder.query(&[("isCrawler", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_notification_count {
        req_builder = req_builder.query(&[("includeNotificationCount", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_as_tree {
        req_builder = req_builder.query(&[("asTree", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_max_tree_depth {
        req_builder = req_builder.query(&[("maxTreeDepth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_use_full_translation_ids {
        req_builder = req_builder.query(&[("useFullTranslationIds", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_parent_id {
        req_builder = req_builder.query(&[("parentId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search_text {
        req_builder = req_builder.query(&[("searchText", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_hash_tags {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("hashTags".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("hashTags", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_user_id {
        req_builder = req_builder.query(&[("userId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_custom_config_str {
        req_builder = req_builder.query(&[("customConfigStr", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetComments200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetComments200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCommentsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_user_notification_count(configuration: &configuration::Configuration, tenant_id: &str, sso: Option<&str>) -> Result<models::GetUserNotificationCount200Response, Error<GetUserNotificationCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_sso = sso;

    let uri_str = format!("{}/user-notifications/get-count", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUserNotificationCount200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUserNotificationCount200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserNotificationCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn get_user_notifications(configuration: &configuration::Configuration, tenant_id: &str, page_size: Option<f64>, after_id: Option<&str>, include_context: Option<models::BooleanQueryParam>, after_created_at: Option<f64>, unread_only: Option<models::BooleanQueryParam>, dm_only: Option<models::BooleanQueryParam>, no_dm: Option<models::BooleanQueryParam>, include_translations: Option<models::BooleanQueryParam>, sso: Option<&str>) -> Result<models::GetUserNotifications200Response, Error<GetUserNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_page_size = page_size;
    let p_after_id = after_id;
    let p_include_context = include_context;
    let p_after_created_at = after_created_at;
    let p_unread_only = unread_only;
    let p_dm_only = dm_only;
    let p_no_dm = no_dm;
    let p_include_translations = include_translations;
    let p_sso = sso;

    let uri_str = format!("{}/user-notifications", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("pageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after_id {
        req_builder = req_builder.query(&[("afterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_context {
        req_builder = req_builder.query(&[("includeContext", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after_created_at {
        req_builder = req_builder.query(&[("afterCreatedAt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unread_only {
        req_builder = req_builder.query(&[("unreadOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dm_only {
        req_builder = req_builder.query(&[("dmOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_no_dm {
        req_builder = req_builder.query(&[("noDm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_include_translations {
        req_builder = req_builder.query(&[("includeTranslations", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetUserNotifications200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetUserNotifications200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUserNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn lock_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, broadcast_id: &str, sso: Option<&str>) -> Result<models::LockComment200Response, Error<LockCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_broadcast_id = broadcast_id;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/lock", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LockComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LockComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LockCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn pin_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, broadcast_id: &str, sso: Option<&str>) -> Result<models::PinComment200Response, Error<PinCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_broadcast_id = broadcast_id;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/pin", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PinComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PinComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PinCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn reset_user_notification_count(configuration: &configuration::Configuration, tenant_id: &str, sso: Option<&str>) -> Result<models::ResetUserNotifications200Response, Error<ResetUserNotificationCountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_sso = sso;

    let uri_str = format!("{}/user-notifications/reset-count", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResetUserNotifications200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResetUserNotifications200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetUserNotificationCountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn reset_user_notifications(configuration: &configuration::Configuration, tenant_id: &str, after_id: Option<&str>, after_created_at: Option<f64>, unread_only: Option<models::BooleanQueryParam>, dm_only: Option<models::BooleanQueryParam>, no_dm: Option<models::BooleanQueryParam>, sso: Option<&str>) -> Result<models::ResetUserNotifications200Response, Error<ResetUserNotificationsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_after_id = after_id;
    let p_after_created_at = after_created_at;
    let p_unread_only = unread_only;
    let p_dm_only = dm_only;
    let p_no_dm = no_dm;
    let p_sso = sso;

    let uri_str = format!("{}/user-notifications/reset", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    if let Some(ref param_value) = p_after_id {
        req_builder = req_builder.query(&[("afterId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_after_created_at {
        req_builder = req_builder.query(&[("afterCreatedAt", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_unread_only {
        req_builder = req_builder.query(&[("unreadOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_dm_only {
        req_builder = req_builder.query(&[("dmOnly", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_no_dm {
        req_builder = req_builder.query(&[("noDm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResetUserNotifications200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResetUserNotifications200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetUserNotificationsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn set_comment_text(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, broadcast_id: &str, edit_key: &str, comment_text_update_request: models::CommentTextUpdateRequest, sso: Option<&str>) -> Result<models::SetCommentText200Response, Error<SetCommentTextError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_broadcast_id = broadcast_id;
    let p_edit_key = edit_key;
    let p_comment_text_update_request = comment_text_update_request;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/update-text", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    req_builder = req_builder.query(&[("editKey", &p_edit_key.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_comment_text_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SetCommentText200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SetCommentText200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SetCommentTextError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn un_block_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, block_from_comment_params: models::BlockFromCommentParams, sso: Option<&str>) -> Result<models::UnBlockComment200Response, Error<UnBlockCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_block_from_comment_params = block_from_comment_params;
    let p_sso = sso;

    let uri_str = format!("{}/block-from-comment/{commentId}", configuration.base_path, commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_block_from_comment_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UnBlockComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UnBlockComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnBlockCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn un_lock_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, broadcast_id: &str, sso: Option<&str>) -> Result<models::LockComment200Response, Error<UnLockCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_broadcast_id = broadcast_id;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/unlock", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LockComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LockComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnLockCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn un_pin_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, broadcast_id: &str, sso: Option<&str>) -> Result<models::PinComment200Response, Error<UnPinCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_broadcast_id = broadcast_id;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/unpin", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PinComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PinComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UnPinCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable or disable notifications for a specific comment.
pub async fn update_user_notification_comment_subscription_status(configuration: &configuration::Configuration, tenant_id: &str, notification_id: &str, opted_in_or_out: &str, comment_id: &str, sso: Option<&str>) -> Result<models::UpdateUserNotificationStatus200Response, Error<UpdateUserNotificationCommentSubscriptionStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_notification_id = notification_id;
    let p_opted_in_or_out = opted_in_or_out;
    let p_comment_id = comment_id;
    let p_sso = sso;

    let uri_str = format!("{}/user-notifications/{notificationId}/mark-opted/{optedInOrOut}", configuration.base_path, notificationId=crate::apis::urlencode(p_notification_id), optedInOrOut=crate::apis::urlencode(p_opted_in_or_out));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    req_builder = req_builder.query(&[("commentId", &p_comment_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateUserNotificationStatus200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateUserNotificationStatus200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserNotificationCommentSubscriptionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enable or disable notifications for a page. When users are subscribed to a page, notifications are created for new root comments, and also
pub async fn update_user_notification_page_subscription_status(configuration: &configuration::Configuration, tenant_id: &str, url_id: &str, url: &str, page_title: &str, subscribed_or_unsubscribed: &str, sso: Option<&str>) -> Result<models::UpdateUserNotificationStatus200Response, Error<UpdateUserNotificationPageSubscriptionStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_url_id = url_id;
    let p_url = url;
    let p_page_title = page_title;
    let p_subscribed_or_unsubscribed = subscribed_or_unsubscribed;
    let p_sso = sso;

    let uri_str = format!("{}/user-notifications/set-subscription-state/{subscribedOrUnsubscribed}", configuration.base_path, subscribedOrUnsubscribed=crate::apis::urlencode(p_subscribed_or_unsubscribed));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    req_builder = req_builder.query(&[("urlId", &p_url_id.to_string())]);
    req_builder = req_builder.query(&[("url", &p_url.to_string())]);
    req_builder = req_builder.query(&[("pageTitle", &p_page_title.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateUserNotificationStatus200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateUserNotificationStatus200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserNotificationPageSubscriptionStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn update_user_notification_status(configuration: &configuration::Configuration, tenant_id: &str, notification_id: &str, new_status: &str, sso: Option<&str>) -> Result<models::UpdateUserNotificationStatus200Response, Error<UpdateUserNotificationStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_notification_id = notification_id;
    let p_new_status = new_status;
    let p_sso = sso;

    let uri_str = format!("{}/user-notifications/{notificationId}/mark/{newStatus}", configuration.base_path, notificationId=crate::apis::urlencode(p_notification_id), newStatus=crate::apis::urlencode(p_new_status));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("tenantId", &p_tenant_id.to_string())]);
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UpdateUserNotificationStatus200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UpdateUserNotificationStatus200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateUserNotificationStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

pub async fn vote_comment(configuration: &configuration::Configuration, tenant_id: &str, comment_id: &str, url_id: &str, broadcast_id: &str, vote_body_params: models::VoteBodyParams, session_id: Option<&str>, sso: Option<&str>) -> Result<models::VoteComment200Response, Error<VoteCommentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_tenant_id = tenant_id;
    let p_comment_id = comment_id;
    let p_url_id = url_id;
    let p_broadcast_id = broadcast_id;
    let p_vote_body_params = vote_body_params;
    let p_session_id = session_id;
    let p_sso = sso;

    let uri_str = format!("{}/comments/{tenantId}/{commentId}/vote", configuration.base_path, tenantId=crate::apis::urlencode(p_tenant_id), commentId=crate::apis::urlencode(p_comment_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("urlId", &p_url_id.to_string())]);
    req_builder = req_builder.query(&[("broadcastId", &p_broadcast_id.to_string())]);
    if let Some(ref param_value) = p_session_id {
        req_builder = req_builder.query(&[("sessionId", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sso {
        req_builder = req_builder.query(&[("sso", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_vote_body_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VoteComment200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VoteComment200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VoteCommentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

